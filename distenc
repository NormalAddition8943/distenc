#!/usr/bin/env python3
"""
Batch encode videos to x265 with crop detection and concurrency.
Uses token files in a shared directory to coordinate encoding jobs.

Usage:
    distenc --inputs <input_files>... --output-dir <output_dir> \
            --stats-dir <stats_dir> --token-dir <token_dir> \
            [--jobs <num>]
"""

import argparse
import concurrent.futures
import glob
import json
import os
import re
import signal
import subprocess
import sys
import tempfile
import threading
from pathlib import Path
from shutil import which as Which
from threading import Lock

# Configuration
TARGET_WIDTH = "-2"
TARGET_HEIGHT = "720"

FFMPEG_PATH = "ffmpeg"
FFPROBE_PATH = "ffprobe"

SAMPLES = 5
VB_KBPS = 800
AB_KBPS = 80

DETECT_FILTER = f"scale={TARGET_WIDTH}:{TARGET_HEIGHT},cropdetect=round=2"

BASE_X265_PARAMS = (
    "hme=1:hme-search=hex,hex,umh:hme-range=25,25,26:subme=5:"
    "min-keyint=24:keyint=800:cbqpoffs=-3:crqpoffs=-3:rc-lookahead=48:"
    "aq-mode=4:aq-strength=1.0:aq-motion=1:qcomp=0.65:bframes=6:ref=4:"
    "rd=4:dynamic-rd=4:psy-rd=1.8:psy-rdoq=1.0:deblock=-3:"
    "tskip=1:tskip-fast=1:frame-threads=2:limit-sao=1:selective-sao=1:"
    "no-amp=1:no-rect=1:"
    "no-high-tier=1:hdr10-opt=1:vbv-maxrate=8000:vbv-bufsize=12000"
)

TOKENS_LOCK = Lock()
INPROGRESS_TOKENS = set()
RUNNING_PROCS = set()

PROCS_LOCK = Lock()
SHUTTING_DOWN = threading.Event()


def run(cmd, check=True):
    return subprocess.run(
        cmd,
        capture_output=True,
        check=check,
        stdin=subprocess.DEVNULL,
        env={**os.environ, "TERM": "dumb"},
    )


def get_video_duration(path: Path) -> float:
    cmd = [
        FFPROBE_PATH,
        "-v",
        "error",
        "-select_streams",
        "v:0",
        "-show_entries",
        "format=duration",
        "-of",
        "default=noprint_wrappers=1:nokey=1",
        str(path),
    ]
    cp = run(cmd)
    return float(cp.stdout.decode().strip())


def get_dolby_vision_flag(input_path: Path) -> str:
    """
    Returns '1' if the input video file contains Dolby Vision side data,
    otherwise returns '0'.
    """
    cmd = [
        "ffprobe",
        "-v",
        "quiet",
        "-select_streams",
        "v:0",
        "-show_streams",
        "-print_format",
        "json",
        str(input_path),
    ]
    cp = run(cmd)
    data = json.loads(cp.stdout)
    stream = data.get("streams", [{}])[0]
    side_data_list = stream.get("side_data_list", [])
    is_present = any(
        sd.get("side_data_type") == "DOVI configuration record" for sd in side_data_list
    )
    return str(int(is_present))


def get_crop_for_timestamp(input_path: Path, timestamp: float):
    cmd = [
        FFMPEG_PATH,
        "-hide_banner",
        "-ss",
        f"{timestamp:.3f}",
        "-i",
        str(input_path),
        "-frames:v",
        "5",
        "-vf",
        DETECT_FILTER,
        "-f",
        "null",
        "-",
    ]
    cp = run(cmd, check=False)
    stderr = cp.stderr.decode(errors="ignore")
    match = re.findall(r"crop=(\d+):(\d+):(\d+):(\d+)", stderr)
    return tuple(map(int, match[-1])) if match else None


def detect_crop_bounds(input_path: Path) -> str:
    duration = get_video_duration(input_path)
    interval = duration / SAMPLES
    min_x, min_y, max_x, max_y = float("inf"), float("inf"), 0, 0
    for i in range(SAMPLES):
        if SHUTTING_DOWN.is_set():
            raise InterruptedError("Shutdown in progress")
        at_timestamp = i * interval
        result = get_crop_for_timestamp(input_path, at_timestamp)
        if result:
            w, h, x, y = result
            min_x = min(min_x, x)
            min_y = min(min_y, y)
            max_x = max(max_x, x + w)
            max_y = max(max_y, y + h)
            print(
                f"Detected crop of {w}:{h}:{x}:{y} at {at_timestamp:.2f}s: {input_path.name}"
            )

    if min_x == float("inf"):
        raise RuntimeError("No crop detected")

    final_w, final_h = int(max_x - min_x), int(max_y - min_y)
    print(
        f"Finalized crop {final_w}:{final_h}:{int(min_x)}:{int(min_y)}: {input_path.name}"
    )

    return (
        f"zscale={TARGET_WIDTH}:{TARGET_HEIGHT}:filter=spline36:param_a=5,"
        f"crop={final_w}:{final_h}:{int(min_x)}:{int(min_y)},"
        f"cas=strength=0.13"
    )


def encode_video(
    input_path: Path, output_path: Path, temp_path: Path, token_path: Path
):
    vf_filter = detect_crop_bounds(input_path)

    dolby_vision_flag = get_dolby_vision_flag(input_path)

    stats_path = temp_path.with_suffix(".stats")

    # First pass (turbo, no audio)
    first_pass_cmd = [
        FFMPEG_PATH,
        "-hide_banner",
        "-stats",
        "-y",
        "-i",
        str(input_path),
        "-vf",
        vf_filter,
        "-dolbyvision",
        dolby_vision_flag,
        "-c:v",
        "libx265",
        "-pix_fmt",
        "yuv420p10le",
        "-b:v",
        f"{VB_KBPS}k",
        "-preset",
        "slower",
        "-x265-params",
        f"pass=1:stats={stats_path}:no-slow-firstpass=1:{BASE_X265_PARAMS}",
        "-an",
        "-f",
        "null",
        "/dev/null" if sys.platform != "win32" else "NUL",
    ]

    # Second pass (with audio)
    second_pass_cmd = [
        FFMPEG_PATH,
        "-hide_banner",
        "-stats",
        "-y",
        "-i",
        str(input_path),
        "-vf",
        vf_filter,
        "-dolbyvision",
        dolby_vision_flag,
        "-c:v",
        "libx265",
        "-pix_fmt",
        "yuv420p10le",
        "-b:v",
        f"{VB_KBPS}k",
        "-preset",
        "slower",
        "-x265-params",
        f"pass=2:stats={stats_path}:{BASE_X265_PARAMS}",
        "-filter:a",
        "dynaudnorm=threshold=-40dB,loudnorm=I=-17:TP=-1.0:LRA=14",
        "-ac",
        "2",
        "-c:a",
        "libopus",
        "-b:a",
        f"{AB_KBPS}k",
        "-frame_duration",
        "60",
        str(output_path),
    ]

    print(f"Running first pass for {input_path.name}")
    cp = None
    with token_path.open("w") as log_file:
        cp = subprocess.run(first_pass_cmd, stdout=log_file, stderr=log_file)

    if cp.returncode == 0:
        print(f"Running second pass for {input_path.name}")
        with token_path.open("a") as log_file:
            cp = subprocess.run(second_pass_cmd, stdout=log_file, stderr=log_file)

    if cp.returncode == 0:
        print(f"Encoding complete: {input_path.name}")
    else:
        print(f"Encoding failed: {input_path.name}")
        token_path.rename(token_path.with_suffix(".error_log"))
        output_path.unlink(missing_ok=True)

    for s in glob.glob(str(stats_path) + "*"):
        Path(s).unlink(missing_ok=True)

    INPROGRESS_TOKENS.discard(token_path)


def temp_filename(base_dir: Path, prefix="", suffix=""):
    fd, path = tempfile.mkstemp(dir=base_dir, prefix=prefix, suffix=suffix)
    Path(path).unlink()  # Remove the file, keeping just the name
    return Path(path)


def process_file(
    input_path: Path, output_dir: Path, scratch_dir: Path, token_dir: Path
):
    if SHUTTING_DOWN.is_set():
        return

    token_path = (token_dir / input_path.name).with_suffix(".token")
    if token_path.exists():
        print(f"Skipping (already encoded or in-progress): {token_path}")
        return

    output_path = output_dir / input_path.name
    if output_path.exists():
        print(f"Skipping (output already exists), so creating token: {output_path}")
        token_path.touch()
        return

    with TOKENS_LOCK:
        INPROGRESS_TOKENS.add(token_path)
    token_path.touch(exist_ok=False)

    temp_path = temp_filename(scratch_dir)

    print(
        f"Starting encode for {input_path.name} with scratch files {temp_path}.*, created: {token_path}"
    )
    encode_video(input_path, output_path, temp_path, token_path)


def restore_terminal():
    try:
        os.system("stty sane")  # resets echo, line discipline, etc.
    except Exception:
        print("Could not restore terminal.", file=sys.stderr)


def cleanup_tokens():
    with TOKENS_LOCK:
        for token_path in INPROGRESS_TOKENS:
            print(f"Cleaning up in-progress token: {token_path}")
            token_path.unlink(missing_ok=True)
        INPROGRESS_TOKENS.clear()


def handle_shutdown(signum, frame):
    print(f"\nReceived signal {signum}, shutting down...")
    SHUTTING_DOWN.set()

    with PROCS_LOCK:
        for proc in list(RUNNING_PROCS):
            if proc.poll() is None:
                print(f"Terminating subprocess PID {proc.pid}")
                proc.terminate()

        for proc in list(RUNNING_PROCS):
            try:
                proc.wait(timeout=5)
            except subprocess.TimeoutExpired:
                print(f"Killing unresponsive subprocess PID {proc.pid}")
                proc.kill()

    cleanup_tokens()
    restore_terminal()
    sys.exit(1)


def is_tool_available(command_name: str, download_url: str):
    if Which(command_name):
        return True  # Tool is available; do nothing

    print(f"'{command_name}' is not found in your system PATH.")
    print(f"Please download it from: {download_url}")
    print("After downloading, ensure it is placed in a directory listed in your PATH.")
    return False


def all_tools_available():
    all_available = True

    for tool, url in [
        (FFMPEG_PATH, "https://ffmpeg.org/"),
        (FFPROBE_PATH, "https://ffmpeg.org/"),
    ]:
        if not is_tool_available(tool, url):
            all_available = False

    return all_available


def main():
    parser = argparse.ArgumentParser(
        description="Batch x265 encode with crop detection, Dolby Vision handling, and concurrent execution."
    )
    parser.add_argument("-i", "--inputs", nargs="+", type=Path, required=True)
    parser.add_argument("-o", "--output-dir", type=Path, required=True)
    parser.add_argument("-s", "--scratch-dir", type=Path, required=True)
    parser.add_argument("-t", "--token-dir", type=Path, required=True)
    parser.add_argument("-j", "--jobs", type=int, default=1)
    args = parser.parse_args()

    if not all_tools_available():
        return

    signal.signal(signal.SIGINT, handle_shutdown)
    signal.signal(signal.SIGTERM, handle_shutdown)

    args.output_dir.mkdir(parents=True, exist_ok=True)
    args.scratch_dir.mkdir(parents=True, exist_ok=True)
    args.token_dir.mkdir(parents=True, exist_ok=True)

    print("Starting encoding batch...")

    try:
        with concurrent.futures.ThreadPoolExecutor(max_workers=args.jobs) as executor:
            futures = [
                executor.submit(
                    process_file, inp, args.output_dir, args.scratch_dir, args.token_dir
                )
                for inp in args.inputs
                if inp.is_file()
            ]
            for future in concurrent.futures.as_completed(futures):
                if SHUTTING_DOWN.is_set():
                    break
                try:
                    future.result()
                except Exception as exc:
                    print(f"Error: {exc}", file=sys.stderr)
    except KeyboardInterrupt:
        handle_shutdown(signal.SIGINT, None)

    cleanup_tokens()
    restore_terminal()
    print("Batch complete.")


if __name__ == "__main__":
    main()
